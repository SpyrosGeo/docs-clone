{"ast":null,"code":"import Delta from 'quill-delta';\nimport DeltaOp from 'quill-delta/lib/op';\nimport Parchment from 'parchment';\nimport CodeBlock from '../formats/code';\nimport CursorBlot from '../blots/cursor';\nimport Block, { bubbleFormats } from '../blots/block';\nimport Break from '../blots/break';\nimport clone from 'clone';\nimport equal from 'deep-equal';\nimport extend from 'extend';\nconst ASCII = /^[ -~]*$/;\n\nclass Editor {\n  constructor(scroll) {\n    this.scroll = scroll;\n    this.delta = this.getDelta();\n  }\n\n  applyDelta(delta) {\n    let consumeNextNewline = false;\n    this.scroll.update();\n    let scrollLength = this.scroll.length();\n    this.scroll.batchStart();\n    delta = normalizeDelta(delta);\n    delta.reduce((index, op) => {\n      let length = op.retain || op.delete || op.insert.length || 1;\n      let attributes = op.attributes || {};\n\n      if (op.insert != null) {\n        if (typeof op.insert === 'string') {\n          let text = op.insert;\n\n          if (text.endsWith('\\n') && consumeNextNewline) {\n            consumeNextNewline = false;\n            text = text.slice(0, -1);\n          }\n\n          if (index >= scrollLength && !text.endsWith('\\n')) {\n            consumeNextNewline = true;\n          }\n\n          this.scroll.insertAt(index, text);\n          let [line, offset] = this.scroll.line(index);\n          let formats = extend({}, bubbleFormats(line));\n\n          if (line instanceof Block) {\n            let [leaf] = line.descendant(Parchment.Leaf, offset);\n            formats = extend(formats, bubbleFormats(leaf));\n          }\n\n          attributes = DeltaOp.attributes.diff(formats, attributes) || {};\n        } else if (typeof op.insert === 'object') {\n          let key = Object.keys(op.insert)[0]; // There should only be one key\n\n          if (key == null) return index;\n          this.scroll.insertAt(index, key, op.insert[key]);\n        }\n\n        scrollLength += length;\n      }\n\n      Object.keys(attributes).forEach(name => {\n        this.scroll.formatAt(index, length, name, attributes[name]);\n      });\n      return index + length;\n    }, 0);\n    delta.reduce((index, op) => {\n      if (typeof op.delete === 'number') {\n        this.scroll.deleteAt(index, op.delete);\n        return index;\n      }\n\n      return index + (op.retain || op.insert.length || 1);\n    }, 0);\n    this.scroll.batchEnd();\n    return this.update(delta);\n  }\n\n  deleteText(index, length) {\n    this.scroll.deleteAt(index, length);\n    return this.update(new Delta().retain(index).delete(length));\n  }\n\n  formatLine(index, length, formats = {}) {\n    this.scroll.update();\n    Object.keys(formats).forEach(format => {\n      if (this.scroll.whitelist != null && !this.scroll.whitelist[format]) return;\n      let lines = this.scroll.lines(index, Math.max(length, 1));\n      let lengthRemaining = length;\n      lines.forEach(line => {\n        let lineLength = line.length();\n\n        if (!(line instanceof CodeBlock)) {\n          line.format(format, formats[format]);\n        } else {\n          let codeIndex = index - line.offset(this.scroll);\n          let codeLength = line.newlineIndex(codeIndex + lengthRemaining) - codeIndex + 1;\n          line.formatAt(codeIndex, codeLength, format, formats[format]);\n        }\n\n        lengthRemaining -= lineLength;\n      });\n    });\n    this.scroll.optimize();\n    return this.update(new Delta().retain(index).retain(length, clone(formats)));\n  }\n\n  formatText(index, length, formats = {}) {\n    Object.keys(formats).forEach(format => {\n      this.scroll.formatAt(index, length, format, formats[format]);\n    });\n    return this.update(new Delta().retain(index).retain(length, clone(formats)));\n  }\n\n  getContents(index, length) {\n    return this.delta.slice(index, index + length);\n  }\n\n  getDelta() {\n    return this.scroll.lines().reduce((delta, line) => {\n      return delta.concat(line.delta());\n    }, new Delta());\n  }\n\n  getFormat(index, length = 0) {\n    let lines = [],\n        leaves = [];\n\n    if (length === 0) {\n      this.scroll.path(index).forEach(function (path) {\n        let [blot] = path;\n\n        if (blot instanceof Block) {\n          lines.push(blot);\n        } else if (blot instanceof Parchment.Leaf) {\n          leaves.push(blot);\n        }\n      });\n    } else {\n      lines = this.scroll.lines(index, length);\n      leaves = this.scroll.descendants(Parchment.Leaf, index, length);\n    }\n\n    let formatsArr = [lines, leaves].map(function (blots) {\n      if (blots.length === 0) return {};\n      let formats = bubbleFormats(blots.shift());\n\n      while (Object.keys(formats).length > 0) {\n        let blot = blots.shift();\n        if (blot == null) return formats;\n        formats = combineFormats(bubbleFormats(blot), formats);\n      }\n\n      return formats;\n    });\n    return extend.apply(extend, formatsArr);\n  }\n\n  getText(index, length) {\n    return this.getContents(index, length).filter(function (op) {\n      return typeof op.insert === 'string';\n    }).map(function (op) {\n      return op.insert;\n    }).join('');\n  }\n\n  insertEmbed(index, embed, value) {\n    this.scroll.insertAt(index, embed, value);\n    return this.update(new Delta().retain(index).insert({\n      [embed]: value\n    }));\n  }\n\n  insertText(index, text, formats = {}) {\n    text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n    this.scroll.insertAt(index, text);\n    Object.keys(formats).forEach(format => {\n      this.scroll.formatAt(index, text.length, format, formats[format]);\n    });\n    return this.update(new Delta().retain(index).insert(text, clone(formats)));\n  }\n\n  isBlank() {\n    if (this.scroll.children.length == 0) return true;\n    if (this.scroll.children.length > 1) return false;\n    let block = this.scroll.children.head;\n    if (block.statics.blotName !== Block.blotName) return false;\n    if (block.children.length > 1) return false;\n    return block.children.head instanceof Break;\n  }\n\n  removeFormat(index, length) {\n    let text = this.getText(index, length);\n    let [line, offset] = this.scroll.line(index + length);\n    let suffixLength = 0,\n        suffix = new Delta();\n\n    if (line != null) {\n      if (!(line instanceof CodeBlock)) {\n        suffixLength = line.length() - offset;\n      } else {\n        suffixLength = line.newlineIndex(offset) - offset + 1;\n      }\n\n      suffix = line.delta().slice(offset, offset + suffixLength - 1).insert('\\n');\n    }\n\n    let contents = this.getContents(index, length + suffixLength);\n    let diff = contents.diff(new Delta().insert(text).concat(suffix));\n    let delta = new Delta().retain(index).concat(diff);\n    return this.applyDelta(delta);\n  }\n\n  update(change, mutations = [], cursorIndex = undefined) {\n    let oldDelta = this.delta;\n\n    if (mutations.length === 1 && mutations[0].type === 'characterData' && mutations[0].target.data.match(ASCII) && Parchment.find(mutations[0].target)) {\n      // Optimization for character changes\n      let textBlot = Parchment.find(mutations[0].target);\n      let formats = bubbleFormats(textBlot);\n      let index = textBlot.offset(this.scroll);\n      let oldValue = mutations[0].oldValue.replace(CursorBlot.CONTENTS, '');\n      let oldText = new Delta().insert(oldValue);\n      let newText = new Delta().insert(textBlot.value());\n      let diffDelta = new Delta().retain(index).concat(oldText.diff(newText, cursorIndex));\n      change = diffDelta.reduce(function (delta, op) {\n        if (op.insert) {\n          return delta.insert(op.insert, formats);\n        } else {\n          return delta.push(op);\n        }\n      }, new Delta());\n      this.delta = oldDelta.compose(change);\n    } else {\n      this.delta = this.getDelta();\n\n      if (!change || !equal(oldDelta.compose(change), this.delta)) {\n        change = oldDelta.diff(this.delta, cursorIndex);\n      }\n    }\n\n    return change;\n  }\n\n}\n\nfunction combineFormats(formats, combined) {\n  return Object.keys(combined).reduce(function (merged, name) {\n    if (formats[name] == null) return merged;\n\n    if (combined[name] === formats[name]) {\n      merged[name] = combined[name];\n    } else if (Array.isArray(combined[name])) {\n      if (combined[name].indexOf(formats[name]) < 0) {\n        merged[name] = combined[name].concat([formats[name]]);\n      }\n    } else {\n      merged[name] = [combined[name], formats[name]];\n    }\n\n    return merged;\n  }, {});\n}\n\nfunction normalizeDelta(delta) {\n  return delta.reduce(function (delta, op) {\n    if (op.insert === 1) {\n      let attributes = clone(op.attributes);\n      delete attributes['image'];\n      return delta.insert({\n        image: op.attributes.image\n      }, attributes);\n    }\n\n    if (op.attributes != null && (op.attributes.list === true || op.attributes.bullet === true)) {\n      op = clone(op);\n\n      if (op.attributes.list) {\n        op.attributes.list = 'ordered';\n      } else {\n        op.attributes.list = 'bullet';\n        delete op.attributes.bullet;\n      }\n    }\n\n    if (typeof op.insert === 'string') {\n      let text = op.insert.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n      return delta.insert(text, op.attributes);\n    }\n\n    return delta.push(op);\n  }, new Delta());\n}\n\nexport default Editor;","map":{"version":3,"sources":["/home/thatguy/My-repos/Javascript/React/docs-clone/client/node_modules/quill/core/editor.js"],"names":["Delta","DeltaOp","Parchment","CodeBlock","CursorBlot","Block","bubbleFormats","Break","clone","equal","extend","ASCII","Editor","constructor","scroll","delta","getDelta","applyDelta","consumeNextNewline","update","scrollLength","length","batchStart","normalizeDelta","reduce","index","op","retain","delete","insert","attributes","text","endsWith","slice","insertAt","line","offset","formats","leaf","descendant","Leaf","diff","key","Object","keys","forEach","name","formatAt","deleteAt","batchEnd","deleteText","formatLine","format","whitelist","lines","Math","max","lengthRemaining","lineLength","codeIndex","codeLength","newlineIndex","optimize","formatText","getContents","concat","getFormat","leaves","path","blot","push","descendants","formatsArr","map","blots","shift","combineFormats","apply","getText","filter","join","insertEmbed","embed","value","insertText","replace","isBlank","children","block","head","statics","blotName","removeFormat","suffixLength","suffix","contents","change","mutations","cursorIndex","undefined","oldDelta","type","target","data","match","find","textBlot","oldValue","CONTENTS","oldText","newText","diffDelta","compose","combined","merged","Array","isArray","indexOf","image","list","bullet"],"mappings":"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","sourcesContent":["import Delta from 'quill-delta';\nimport DeltaOp from 'quill-delta/lib/op';\nimport Parchment from 'parchment';\nimport CodeBlock from '../formats/code';\nimport CursorBlot from '../blots/cursor';\nimport Block, { bubbleFormats } from '../blots/block';\nimport Break from '../blots/break';\nimport clone from 'clone';\nimport equal from 'deep-equal';\nimport extend from 'extend';\n\n\nconst ASCII = /^[ -~]*$/;\n\n\nclass Editor {\n  constructor(scroll) {\n    this.scroll = scroll;\n    this.delta = this.getDelta();\n  }\n\n  applyDelta(delta) {\n    let consumeNextNewline = false;\n    this.scroll.update();\n    let scrollLength = this.scroll.length();\n    this.scroll.batchStart();\n    delta = normalizeDelta(delta);\n    delta.reduce((index, op) => {\n      let length = op.retain || op.delete || op.insert.length || 1;\n      let attributes = op.attributes || {};\n      if (op.insert != null) {\n        if (typeof op.insert === 'string') {\n          let text = op.insert;\n          if (text.endsWith('\\n') && consumeNextNewline) {\n            consumeNextNewline = false;\n            text = text.slice(0, -1);\n          }\n          if (index >= scrollLength && !text.endsWith('\\n')) {\n            consumeNextNewline = true;\n          }\n          this.scroll.insertAt(index, text);\n          let [line, offset] = this.scroll.line(index);\n          let formats = extend({}, bubbleFormats(line));\n          if (line instanceof Block) {\n            let [leaf, ] = line.descendant(Parchment.Leaf, offset);\n            formats = extend(formats, bubbleFormats(leaf));\n          }\n          attributes = DeltaOp.attributes.diff(formats, attributes) || {};\n        } else if (typeof op.insert === 'object') {\n          let key = Object.keys(op.insert)[0];  // There should only be one key\n          if (key == null) return index;\n          this.scroll.insertAt(index, key, op.insert[key]);\n        }\n        scrollLength += length;\n      }\n      Object.keys(attributes).forEach((name) => {\n        this.scroll.formatAt(index, length, name, attributes[name]);\n      });\n      return index + length;\n    }, 0);\n    delta.reduce((index, op) => {\n      if (typeof op.delete === 'number') {\n        this.scroll.deleteAt(index, op.delete);\n        return index;\n      }\n      return index + (op.retain || op.insert.length || 1);\n    }, 0);\n    this.scroll.batchEnd();\n    return this.update(delta);\n  }\n\n  deleteText(index, length) {\n    this.scroll.deleteAt(index, length);\n    return this.update(new Delta().retain(index).delete(length));\n  }\n\n  formatLine(index, length, formats = {}) {\n    this.scroll.update();\n    Object.keys(formats).forEach((format) => {\n      if (this.scroll.whitelist != null && !this.scroll.whitelist[format]) return;\n      let lines = this.scroll.lines(index, Math.max(length, 1));\n      let lengthRemaining = length;\n      lines.forEach((line) => {\n        let lineLength = line.length();\n        if (!(line instanceof CodeBlock)) {\n          line.format(format, formats[format]);\n        } else {\n          let codeIndex = index - line.offset(this.scroll);\n          let codeLength = line.newlineIndex(codeIndex + lengthRemaining) - codeIndex + 1;\n          line.formatAt(codeIndex, codeLength, format, formats[format]);\n        }\n        lengthRemaining -= lineLength;\n      });\n    });\n    this.scroll.optimize();\n    return this.update(new Delta().retain(index).retain(length, clone(formats)));\n  }\n\n  formatText(index, length, formats = {}) {\n    Object.keys(formats).forEach((format) => {\n      this.scroll.formatAt(index, length, format, formats[format]);\n    });\n    return this.update(new Delta().retain(index).retain(length, clone(formats)));\n  }\n\n  getContents(index, length) {\n    return this.delta.slice(index, index + length);\n  }\n\n  getDelta() {\n    return this.scroll.lines().reduce((delta, line) => {\n      return delta.concat(line.delta());\n    }, new Delta());\n  }\n\n  getFormat(index, length = 0) {\n    let lines = [], leaves = [];\n    if (length === 0) {\n      this.scroll.path(index).forEach(function(path) {\n        let [blot, ] = path;\n        if (blot instanceof Block) {\n          lines.push(blot);\n        } else if (blot instanceof Parchment.Leaf) {\n          leaves.push(blot);\n        }\n      });\n    } else {\n      lines = this.scroll.lines(index, length);\n      leaves = this.scroll.descendants(Parchment.Leaf, index, length);\n    }\n    let formatsArr = [lines, leaves].map(function(blots) {\n      if (blots.length === 0) return {};\n      let formats = bubbleFormats(blots.shift());\n      while (Object.keys(formats).length > 0) {\n        let blot = blots.shift();\n        if (blot == null) return formats;\n        formats = combineFormats(bubbleFormats(blot), formats);\n      }\n      return formats;\n    });\n    return extend.apply(extend, formatsArr);\n  }\n\n  getText(index, length) {\n    return this.getContents(index, length).filter(function(op) {\n      return typeof op.insert === 'string';\n    }).map(function(op) {\n      return op.insert;\n    }).join('');\n  }\n\n  insertEmbed(index, embed, value) {\n    this.scroll.insertAt(index, embed, value);\n    return this.update(new Delta().retain(index).insert({ [embed]: value }));\n  }\n\n  insertText(index, text, formats = {}) {\n    text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n    this.scroll.insertAt(index, text);\n    Object.keys(formats).forEach((format) => {\n      this.scroll.formatAt(index, text.length, format, formats[format]);\n    });\n    return this.update(new Delta().retain(index).insert(text, clone(formats)));\n  }\n\n  isBlank() {\n    if (this.scroll.children.length == 0) return true;\n    if (this.scroll.children.length > 1) return false;\n    let block = this.scroll.children.head;\n    if (block.statics.blotName !== Block.blotName) return false;\n    if (block.children.length > 1) return false;\n    return block.children.head instanceof Break;\n  }\n\n  removeFormat(index, length) {\n    let text = this.getText(index, length);\n    let [line, offset] = this.scroll.line(index + length);\n    let suffixLength = 0, suffix = new Delta();\n    if (line != null) {\n      if (!(line instanceof CodeBlock)) {\n        suffixLength = line.length() - offset;\n      } else {\n        suffixLength = line.newlineIndex(offset) - offset + 1;\n      }\n      suffix = line.delta().slice(offset, offset + suffixLength - 1).insert('\\n');\n    }\n    let contents = this.getContents(index, length + suffixLength);\n    let diff = contents.diff(new Delta().insert(text).concat(suffix));\n    let delta = new Delta().retain(index).concat(diff);\n    return this.applyDelta(delta);\n  }\n\n  update(change, mutations = [], cursorIndex = undefined) {\n    let oldDelta = this.delta;\n    if (mutations.length === 1 &&\n        mutations[0].type === 'characterData' &&\n        mutations[0].target.data.match(ASCII) &&\n        Parchment.find(mutations[0].target)) {\n      // Optimization for character changes\n      let textBlot = Parchment.find(mutations[0].target);\n      let formats = bubbleFormats(textBlot);\n      let index = textBlot.offset(this.scroll);\n      let oldValue = mutations[0].oldValue.replace(CursorBlot.CONTENTS, '');\n      let oldText = new Delta().insert(oldValue);\n      let newText = new Delta().insert(textBlot.value());\n      let diffDelta = new Delta().retain(index).concat(oldText.diff(newText, cursorIndex));\n      change = diffDelta.reduce(function(delta, op) {\n        if (op.insert) {\n          return delta.insert(op.insert, formats);\n        } else {\n          return delta.push(op);\n        }\n      }, new Delta());\n      this.delta = oldDelta.compose(change);\n    } else {\n      this.delta = this.getDelta();\n      if (!change || !equal(oldDelta.compose(change), this.delta)) {\n        change = oldDelta.diff(this.delta, cursorIndex);\n      }\n    }\n    return change;\n  }\n}\n\n\nfunction combineFormats(formats, combined) {\n  return Object.keys(combined).reduce(function(merged, name) {\n    if (formats[name] == null) return merged;\n    if (combined[name] === formats[name]) {\n      merged[name] = combined[name];\n    } else if (Array.isArray(combined[name])) {\n      if (combined[name].indexOf(formats[name]) < 0) {\n        merged[name] = combined[name].concat([formats[name]]);\n      }\n    } else {\n      merged[name] = [combined[name], formats[name]];\n    }\n    return merged;\n  }, {});\n}\n\nfunction normalizeDelta(delta) {\n  return delta.reduce(function(delta, op) {\n    if (op.insert === 1) {\n      let attributes = clone(op.attributes);\n      delete attributes['image'];\n      return delta.insert({ image: op.attributes.image }, attributes);\n    }\n    if (op.attributes != null && (op.attributes.list === true || op.attributes.bullet === true)) {\n      op = clone(op);\n      if (op.attributes.list) {\n        op.attributes.list = 'ordered';\n      } else {\n        op.attributes.list = 'bullet';\n        delete op.attributes.bullet;\n      }\n    }\n    if (typeof op.insert === 'string') {\n      let text = op.insert.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n      return delta.insert(text, op.attributes);\n    }\n    return delta.push(op);\n  }, new Delta());\n}\n\n\nexport default Editor;\n"]},"metadata":{},"sourceType":"module"}