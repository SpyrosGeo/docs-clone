{"ast":null,"code":"import Parchment from 'parchment';\nimport TextBlot from './text';\n\nclass Cursor extends Parchment.Embed {\n  static value() {\n    return undefined;\n  }\n\n  constructor(domNode, selection) {\n    super(domNode);\n    this.selection = selection;\n    this.textNode = document.createTextNode(Cursor.CONTENTS);\n    this.domNode.appendChild(this.textNode);\n    this._length = 0;\n  }\n\n  detach() {\n    // super.detach() will also clear domNode.__blot\n    if (this.parent != null) this.parent.removeChild(this);\n  }\n\n  format(name, value) {\n    if (this._length !== 0) {\n      return super.format(name, value);\n    }\n\n    let target = this,\n        index = 0;\n\n    while (target != null && target.statics.scope !== Parchment.Scope.BLOCK_BLOT) {\n      index += target.offset(target.parent);\n      target = target.parent;\n    }\n\n    if (target != null) {\n      this._length = Cursor.CONTENTS.length;\n      target.optimize();\n      target.formatAt(index, Cursor.CONTENTS.length, name, value);\n      this._length = 0;\n    }\n  }\n\n  index(node, offset) {\n    if (node === this.textNode) return 0;\n    return super.index(node, offset);\n  }\n\n  length() {\n    return this._length;\n  }\n\n  position() {\n    return [this.textNode, this.textNode.data.length];\n  }\n\n  remove() {\n    super.remove();\n    this.parent = null;\n  }\n\n  restore() {\n    if (this.selection.composing || this.parent == null) return;\n    let textNode = this.textNode;\n    let range = this.selection.getNativeRange();\n    let restoreText, start, end;\n\n    if (range != null && range.start.node === textNode && range.end.node === textNode) {\n      [restoreText, start, end] = [textNode, range.start.offset, range.end.offset];\n    } // Link format will insert text outside of anchor tag\n\n\n    while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {\n      this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);\n    }\n\n    if (this.textNode.data !== Cursor.CONTENTS) {\n      let text = this.textNode.data.split(Cursor.CONTENTS).join('');\n\n      if (this.next instanceof TextBlot) {\n        restoreText = this.next.domNode;\n        this.next.insertAt(0, text);\n        this.textNode.data = Cursor.CONTENTS;\n      } else {\n        this.textNode.data = text;\n        this.parent.insertBefore(Parchment.create(this.textNode), this);\n        this.textNode = document.createTextNode(Cursor.CONTENTS);\n        this.domNode.appendChild(this.textNode);\n      }\n    }\n\n    this.remove();\n\n    if (start != null) {\n      [start, end] = [start, end].map(function (offset) {\n        return Math.max(0, Math.min(restoreText.data.length, offset - 1));\n      });\n      return {\n        startNode: restoreText,\n        startOffset: start,\n        endNode: restoreText,\n        endOffset: end\n      };\n    }\n  }\n\n  update(mutations, context) {\n    if (mutations.some(mutation => {\n      return mutation.type === 'characterData' && mutation.target === this.textNode;\n    })) {\n      let range = this.restore();\n      if (range) context.range = range;\n    }\n  }\n\n  value() {\n    return '';\n  }\n\n}\n\nCursor.blotName = 'cursor';\nCursor.className = 'ql-cursor';\nCursor.tagName = 'span';\nCursor.CONTENTS = \"\\uFEFF\"; // Zero width no break space\n\nexport default Cursor;","map":{"version":3,"sources":["/home/thatguy/My-repos/Javascript/React/docs-clone/client/node_modules/quill/blots/cursor.js"],"names":["Parchment","TextBlot","Cursor","Embed","value","undefined","constructor","domNode","selection","textNode","document","createTextNode","CONTENTS","appendChild","_length","detach","parent","removeChild","format","name","target","index","statics","scope","Scope","BLOCK_BLOT","offset","length","optimize","formatAt","node","position","data","remove","restore","composing","range","getNativeRange","restoreText","start","end","lastChild","parentNode","insertBefore","text","split","join","next","insertAt","create","map","Math","max","min","startNode","startOffset","endNode","endOffset","update","mutations","context","some","mutation","type","blotName","className","tagName"],"mappings":"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","sourcesContent":["import Parchment from 'parchment';\nimport TextBlot from './text';\n\n\nclass Cursor extends Parchment.Embed {\n  static value() {\n    return undefined;\n  }\n\n  constructor(domNode, selection) {\n    super(domNode);\n    this.selection = selection;\n    this.textNode = document.createTextNode(Cursor.CONTENTS);\n    this.domNode.appendChild(this.textNode);\n    this._length = 0;\n  }\n\n  detach() {\n    // super.detach() will also clear domNode.__blot\n    if (this.parent != null) this.parent.removeChild(this);\n  }\n\n  format(name, value) {\n    if (this._length !== 0) {\n      return super.format(name, value);\n    }\n    let target = this, index = 0;\n    while (target != null && target.statics.scope !== Parchment.Scope.BLOCK_BLOT) {\n      index += target.offset(target.parent);\n      target = target.parent;\n    }\n    if (target != null) {\n      this._length = Cursor.CONTENTS.length;\n      target.optimize();\n      target.formatAt(index, Cursor.CONTENTS.length, name, value);\n      this._length = 0;\n    }\n  }\n\n  index(node, offset) {\n    if (node === this.textNode) return 0;\n    return super.index(node, offset);\n  }\n\n  length() {\n    return this._length;\n  }\n\n  position() {\n    return [this.textNode, this.textNode.data.length];\n  }\n\n  remove() {\n    super.remove();\n    this.parent = null;\n  }\n\n  restore() {\n    if (this.selection.composing || this.parent == null) return;\n    let textNode = this.textNode;\n    let range = this.selection.getNativeRange();\n    let restoreText, start, end;\n    if (range != null && range.start.node === textNode && range.end.node === textNode) {\n      [restoreText, start, end] = [textNode, range.start.offset, range.end.offset];\n    }\n    // Link format will insert text outside of anchor tag\n    while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {\n      this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);\n    }\n    if (this.textNode.data !== Cursor.CONTENTS) {\n      let text = this.textNode.data.split(Cursor.CONTENTS).join('');\n      if (this.next instanceof TextBlot) {\n        restoreText = this.next.domNode;\n        this.next.insertAt(0, text);\n        this.textNode.data = Cursor.CONTENTS;\n      } else {\n        this.textNode.data = text;\n        this.parent.insertBefore(Parchment.create(this.textNode), this);\n        this.textNode = document.createTextNode(Cursor.CONTENTS);\n        this.domNode.appendChild(this.textNode);\n      }\n    }\n    this.remove();\n    if (start != null) {\n      [start, end] = [start, end].map(function(offset) {\n        return Math.max(0, Math.min(restoreText.data.length, offset - 1));\n      });\n      return {\n        startNode: restoreText,\n        startOffset: start,\n        endNode: restoreText,\n        endOffset: end\n      };\n    }\n  }\n\n  update(mutations, context) {\n    if (mutations.some((mutation) => {\n      return mutation.type === 'characterData' && mutation.target === this.textNode;\n    })) {\n      let range = this.restore();\n      if (range) context.range = range;\n    }\n  }\n\n  value() {\n    return '';\n  }\n}\nCursor.blotName = 'cursor';\nCursor.className = 'ql-cursor';\nCursor.tagName = 'span';\nCursor.CONTENTS = \"\\uFEFF\";   // Zero width no break space\n\n\nexport default Cursor;\n"]},"metadata":{},"sourceType":"module"}