{"ast":null,"code":"import Parchment from 'parchment';\nimport clone from 'clone';\nimport equal from 'deep-equal';\nimport Emitter from './emitter';\nimport logger from './logger';\nlet debug = logger('quill:selection');\n\nclass Range {\n  constructor(index, length = 0) {\n    this.index = index;\n    this.length = length;\n  }\n\n}\n\nclass Selection {\n  constructor(scroll, emitter) {\n    this.emitter = emitter;\n    this.scroll = scroll;\n    this.composing = false;\n    this.mouseDown = false;\n    this.root = this.scroll.domNode;\n    this.cursor = Parchment.create('cursor', this); // savedRange is last non-null range\n\n    this.lastRange = this.savedRange = new Range(0, 0);\n    this.handleComposition();\n    this.handleDragging();\n    this.emitter.listenDOM('selectionchange', document, () => {\n      if (!this.mouseDown) {\n        setTimeout(this.update.bind(this, Emitter.sources.USER), 1);\n      }\n    });\n    this.emitter.on(Emitter.events.EDITOR_CHANGE, (type, delta) => {\n      if (type === Emitter.events.TEXT_CHANGE && delta.length() > 0) {\n        this.update(Emitter.sources.SILENT);\n      }\n    });\n    this.emitter.on(Emitter.events.SCROLL_BEFORE_UPDATE, () => {\n      if (!this.hasFocus()) return;\n      let native = this.getNativeRange();\n      if (native == null) return;\n      if (native.start.node === this.cursor.textNode) return; // cursor.restore() will handle\n      // TODO unclear if this has negative side effects\n\n      this.emitter.once(Emitter.events.SCROLL_UPDATE, () => {\n        try {\n          this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);\n        } catch (ignored) {}\n      });\n    });\n    this.emitter.on(Emitter.events.SCROLL_OPTIMIZE, (mutations, context) => {\n      if (context.range) {\n        const {\n          startNode,\n          startOffset,\n          endNode,\n          endOffset\n        } = context.range;\n        this.setNativeRange(startNode, startOffset, endNode, endOffset);\n      }\n    });\n    this.update(Emitter.sources.SILENT);\n  }\n\n  handleComposition() {\n    this.root.addEventListener('compositionstart', () => {\n      this.composing = true;\n    });\n    this.root.addEventListener('compositionend', () => {\n      this.composing = false;\n\n      if (this.cursor.parent) {\n        const range = this.cursor.restore();\n        if (!range) return;\n        setTimeout(() => {\n          this.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);\n        }, 1);\n      }\n    });\n  }\n\n  handleDragging() {\n    this.emitter.listenDOM('mousedown', document.body, () => {\n      this.mouseDown = true;\n    });\n    this.emitter.listenDOM('mouseup', document.body, () => {\n      this.mouseDown = false;\n      this.update(Emitter.sources.USER);\n    });\n  }\n\n  focus() {\n    if (this.hasFocus()) return;\n    this.root.focus();\n    this.setRange(this.savedRange);\n  }\n\n  format(format, value) {\n    if (this.scroll.whitelist != null && !this.scroll.whitelist[format]) return;\n    this.scroll.update();\n    let nativeRange = this.getNativeRange();\n    if (nativeRange == null || !nativeRange.native.collapsed || Parchment.query(format, Parchment.Scope.BLOCK)) return;\n\n    if (nativeRange.start.node !== this.cursor.textNode) {\n      let blot = Parchment.find(nativeRange.start.node, false);\n      if (blot == null) return; // TODO Give blot ability to not split\n\n      if (blot instanceof Parchment.Leaf) {\n        let after = blot.split(nativeRange.start.offset);\n        blot.parent.insertBefore(this.cursor, after);\n      } else {\n        blot.insertBefore(this.cursor, nativeRange.start.node); // Should never happen\n      }\n\n      this.cursor.attach();\n    }\n\n    this.cursor.format(format, value);\n    this.scroll.optimize();\n    this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);\n    this.update();\n  }\n\n  getBounds(index, length = 0) {\n    let scrollLength = this.scroll.length();\n    index = Math.min(index, scrollLength - 1);\n    length = Math.min(index + length, scrollLength - 1) - index;\n    let node,\n        [leaf, offset] = this.scroll.leaf(index);\n    if (leaf == null) return null;\n    [node, offset] = leaf.position(offset, true);\n    let range = document.createRange();\n\n    if (length > 0) {\n      range.setStart(node, offset);\n      [leaf, offset] = this.scroll.leaf(index + length);\n      if (leaf == null) return null;\n      [node, offset] = leaf.position(offset, true);\n      range.setEnd(node, offset);\n      return range.getBoundingClientRect();\n    } else {\n      let side = 'left';\n      let rect;\n\n      if (node instanceof Text) {\n        if (offset < node.data.length) {\n          range.setStart(node, offset);\n          range.setEnd(node, offset + 1);\n        } else {\n          range.setStart(node, offset - 1);\n          range.setEnd(node, offset);\n          side = 'right';\n        }\n\n        rect = range.getBoundingClientRect();\n      } else {\n        rect = leaf.domNode.getBoundingClientRect();\n        if (offset > 0) side = 'right';\n      }\n\n      return {\n        bottom: rect.top + rect.height,\n        height: rect.height,\n        left: rect[side],\n        right: rect[side],\n        top: rect.top,\n        width: 0\n      };\n    }\n  }\n\n  getNativeRange() {\n    let selection = document.getSelection();\n    if (selection == null || selection.rangeCount <= 0) return null;\n    let nativeRange = selection.getRangeAt(0);\n    if (nativeRange == null) return null;\n    let range = this.normalizeNative(nativeRange);\n    debug.info('getNativeRange', range);\n    return range;\n  }\n\n  getRange() {\n    let normalized = this.getNativeRange();\n    if (normalized == null) return [null, null];\n    let range = this.normalizedToRange(normalized);\n    return [range, normalized];\n  }\n\n  hasFocus() {\n    return document.activeElement === this.root;\n  }\n\n  normalizedToRange(range) {\n    let positions = [[range.start.node, range.start.offset]];\n\n    if (!range.native.collapsed) {\n      positions.push([range.end.node, range.end.offset]);\n    }\n\n    let indexes = positions.map(position => {\n      let [node, offset] = position;\n      let blot = Parchment.find(node, true);\n      let index = blot.offset(this.scroll);\n\n      if (offset === 0) {\n        return index;\n      } else if (blot instanceof Parchment.Container) {\n        return index + blot.length();\n      } else {\n        return index + blot.index(node, offset);\n      }\n    });\n    let end = Math.min(Math.max(...indexes), this.scroll.length() - 1);\n    let start = Math.min(end, ...indexes);\n    return new Range(start, end - start);\n  }\n\n  normalizeNative(nativeRange) {\n    if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {\n      return null;\n    }\n\n    let range = {\n      start: {\n        node: nativeRange.startContainer,\n        offset: nativeRange.startOffset\n      },\n      end: {\n        node: nativeRange.endContainer,\n        offset: nativeRange.endOffset\n      },\n      native: nativeRange\n    };\n    [range.start, range.end].forEach(function (position) {\n      let node = position.node,\n          offset = position.offset;\n\n      while (!(node instanceof Text) && node.childNodes.length > 0) {\n        if (node.childNodes.length > offset) {\n          node = node.childNodes[offset];\n          offset = 0;\n        } else if (node.childNodes.length === offset) {\n          node = node.lastChild;\n          offset = node instanceof Text ? node.data.length : node.childNodes.length + 1;\n        } else {\n          break;\n        }\n      }\n\n      position.node = node, position.offset = offset;\n    });\n    return range;\n  }\n\n  rangeToNative(range) {\n    let indexes = range.collapsed ? [range.index] : [range.index, range.index + range.length];\n    let args = [];\n    let scrollLength = this.scroll.length();\n    indexes.forEach((index, i) => {\n      index = Math.min(scrollLength - 1, index);\n      let node,\n          [leaf, offset] = this.scroll.leaf(index);\n      [node, offset] = leaf.position(offset, i !== 0);\n      args.push(node, offset);\n    });\n\n    if (args.length < 2) {\n      args = args.concat(args);\n    }\n\n    return args;\n  }\n\n  scrollIntoView(scrollingContainer) {\n    let range = this.lastRange;\n    if (range == null) return;\n    let bounds = this.getBounds(range.index, range.length);\n    if (bounds == null) return;\n    let limit = this.scroll.length() - 1;\n    let [first] = this.scroll.line(Math.min(range.index, limit));\n    let last = first;\n\n    if (range.length > 0) {\n      [last] = this.scroll.line(Math.min(range.index + range.length, limit));\n    }\n\n    if (first == null || last == null) return;\n    let scrollBounds = scrollingContainer.getBoundingClientRect();\n\n    if (bounds.top < scrollBounds.top) {\n      scrollingContainer.scrollTop -= scrollBounds.top - bounds.top;\n    } else if (bounds.bottom > scrollBounds.bottom) {\n      scrollingContainer.scrollTop += bounds.bottom - scrollBounds.bottom;\n    }\n  }\n\n  setNativeRange(startNode, startOffset, endNode = startNode, endOffset = startOffset, force = false) {\n    debug.info('setNativeRange', startNode, startOffset, endNode, endOffset);\n\n    if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {\n      return;\n    }\n\n    let selection = document.getSelection();\n    if (selection == null) return;\n\n    if (startNode != null) {\n      if (!this.hasFocus()) this.root.focus();\n      let native = (this.getNativeRange() || {}).native;\n\n      if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {\n        if (startNode.tagName == \"BR\") {\n          startOffset = [].indexOf.call(startNode.parentNode.childNodes, startNode);\n          startNode = startNode.parentNode;\n        }\n\n        if (endNode.tagName == \"BR\") {\n          endOffset = [].indexOf.call(endNode.parentNode.childNodes, endNode);\n          endNode = endNode.parentNode;\n        }\n\n        let range = document.createRange();\n        range.setStart(startNode, startOffset);\n        range.setEnd(endNode, endOffset);\n        selection.removeAllRanges();\n        selection.addRange(range);\n      }\n    } else {\n      selection.removeAllRanges();\n      this.root.blur();\n      document.body.focus(); // root.blur() not enough on IE11+Travis+SauceLabs (but not local VMs)\n    }\n  }\n\n  setRange(range, force = false, source = Emitter.sources.API) {\n    if (typeof force === 'string') {\n      source = force;\n      force = false;\n    }\n\n    debug.info('setRange', range);\n\n    if (range != null) {\n      let args = this.rangeToNative(range);\n      this.setNativeRange(...args, force);\n    } else {\n      this.setNativeRange(null);\n    }\n\n    this.update(source);\n  }\n\n  update(source = Emitter.sources.USER) {\n    let oldRange = this.lastRange;\n    let [lastRange, nativeRange] = this.getRange();\n    this.lastRange = lastRange;\n\n    if (this.lastRange != null) {\n      this.savedRange = this.lastRange;\n    }\n\n    if (!equal(oldRange, this.lastRange)) {\n      if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {\n        this.cursor.restore();\n      }\n\n      let args = [Emitter.events.SELECTION_CHANGE, clone(this.lastRange), clone(oldRange), source];\n      this.emitter.emit(Emitter.events.EDITOR_CHANGE, ...args);\n\n      if (source !== Emitter.sources.SILENT) {\n        this.emitter.emit(...args);\n      }\n    }\n  }\n\n}\n\nfunction contains(parent, descendant) {\n  try {\n    // Firefox inserts inaccessible nodes around video elements\n    descendant.parentNode;\n  } catch (e) {\n    return false;\n  } // IE11 has bug with Text nodes\n  // https://connect.microsoft.com/IE/feedback/details/780874/node-contains-is-incorrect\n\n\n  if (descendant instanceof Text) {\n    descendant = descendant.parentNode;\n  }\n\n  return parent.contains(descendant);\n}\n\nexport { Range, Selection as default };","map":{"version":3,"sources":["/home/thatguy/My-repos/Javascript/React/docs-clone/client/node_modules/quill/core/selection.js"],"names":["Parchment","clone","equal","Emitter","logger","debug","Range","constructor","index","length","Selection","scroll","emitter","composing","mouseDown","root","domNode","cursor","create","lastRange","savedRange","handleComposition","handleDragging","listenDOM","document","setTimeout","update","bind","sources","USER","on","events","EDITOR_CHANGE","type","delta","TEXT_CHANGE","SILENT","SCROLL_BEFORE_UPDATE","hasFocus","native","getNativeRange","start","node","textNode","once","SCROLL_UPDATE","setNativeRange","offset","end","ignored","SCROLL_OPTIMIZE","mutations","context","range","startNode","startOffset","endNode","endOffset","addEventListener","parent","restore","body","focus","setRange","format","value","whitelist","nativeRange","collapsed","query","Scope","BLOCK","blot","find","Leaf","after","split","insertBefore","attach","optimize","data","getBounds","scrollLength","Math","min","leaf","position","createRange","setStart","setEnd","getBoundingClientRect","side","rect","Text","bottom","top","height","left","right","width","selection","getSelection","rangeCount","getRangeAt","normalizeNative","info","getRange","normalized","normalizedToRange","activeElement","positions","push","indexes","map","Container","max","contains","startContainer","endContainer","forEach","childNodes","lastChild","rangeToNative","args","i","concat","scrollIntoView","scrollingContainer","bounds","limit","first","line","last","scrollBounds","scrollTop","force","parentNode","tagName","indexOf","call","removeAllRanges","addRange","blur","source","API","oldRange","SELECTION_CHANGE","emit","descendant","e","default"],"mappings":"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","sourcesContent":["import Parchment from 'parchment';\nimport clone from 'clone';\nimport equal from 'deep-equal';\nimport Emitter from './emitter';\nimport logger from './logger';\n\nlet debug = logger('quill:selection');\n\n\nclass Range {\n  constructor(index, length = 0) {\n    this.index = index;\n    this.length = length;\n  }\n}\n\n\nclass Selection {\n  constructor(scroll, emitter) {\n    this.emitter = emitter;\n    this.scroll = scroll;\n    this.composing = false;\n    this.mouseDown = false;\n    this.root = this.scroll.domNode;\n    this.cursor = Parchment.create('cursor', this);\n    // savedRange is last non-null range\n    this.lastRange = this.savedRange = new Range(0, 0);\n    this.handleComposition();\n    this.handleDragging();\n    this.emitter.listenDOM('selectionchange', document, () => {\n      if (!this.mouseDown) {\n        setTimeout(this.update.bind(this, Emitter.sources.USER), 1);\n      }\n    });\n    this.emitter.on(Emitter.events.EDITOR_CHANGE, (type, delta) => {\n      if (type === Emitter.events.TEXT_CHANGE && delta.length() > 0) {\n        this.update(Emitter.sources.SILENT);\n      }\n    });\n    this.emitter.on(Emitter.events.SCROLL_BEFORE_UPDATE, () => {\n      if (!this.hasFocus()) return;\n      let native = this.getNativeRange();\n      if (native == null) return;\n      if (native.start.node === this.cursor.textNode) return;  // cursor.restore() will handle\n      // TODO unclear if this has negative side effects\n      this.emitter.once(Emitter.events.SCROLL_UPDATE, () => {\n        try {\n          this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);\n        } catch (ignored) {}\n      });\n    });\n    this.emitter.on(Emitter.events.SCROLL_OPTIMIZE, (mutations, context) => {\n      if (context.range) {\n        const { startNode, startOffset, endNode, endOffset } = context.range;\n        this.setNativeRange(startNode, startOffset, endNode, endOffset);\n      }\n    });\n    this.update(Emitter.sources.SILENT);\n  }\n\n  handleComposition() {\n    this.root.addEventListener('compositionstart', () => {\n      this.composing = true;\n    });\n    this.root.addEventListener('compositionend', () => {\n      this.composing = false;\n      if (this.cursor.parent) {\n        const range = this.cursor.restore();\n        if (!range) return;\n        setTimeout(() => {\n          this.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);\n        }, 1);\n      }\n    });\n  }\n\n  handleDragging() {\n    this.emitter.listenDOM('mousedown', document.body, () => {\n      this.mouseDown = true;\n    });\n    this.emitter.listenDOM('mouseup', document.body, () => {\n      this.mouseDown = false;\n      this.update(Emitter.sources.USER);\n    });\n  }\n\n  focus() {\n    if (this.hasFocus()) return;\n    this.root.focus();\n    this.setRange(this.savedRange);\n  }\n\n  format(format, value) {\n    if (this.scroll.whitelist != null && !this.scroll.whitelist[format]) return;\n    this.scroll.update();\n    let nativeRange = this.getNativeRange();\n    if (nativeRange == null || !nativeRange.native.collapsed || Parchment.query(format, Parchment.Scope.BLOCK)) return;\n    if (nativeRange.start.node !== this.cursor.textNode) {\n      let blot = Parchment.find(nativeRange.start.node, false);\n      if (blot == null) return;\n      // TODO Give blot ability to not split\n      if (blot instanceof Parchment.Leaf) {\n        let after = blot.split(nativeRange.start.offset);\n        blot.parent.insertBefore(this.cursor, after);\n      } else {\n        blot.insertBefore(this.cursor, nativeRange.start.node);  // Should never happen\n      }\n      this.cursor.attach();\n    }\n    this.cursor.format(format, value);\n    this.scroll.optimize();\n    this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);\n    this.update();\n  }\n\n  getBounds(index, length = 0) {\n    let scrollLength = this.scroll.length();\n    index = Math.min(index, scrollLength - 1);\n    length = Math.min(index + length, scrollLength - 1) - index;\n    let node, [leaf, offset] = this.scroll.leaf(index);\n    if (leaf == null) return null;\n    [node, offset] = leaf.position(offset, true);\n    let range = document.createRange();\n    if (length > 0) {\n      range.setStart(node, offset);\n      [leaf, offset] = this.scroll.leaf(index + length);\n      if (leaf == null) return null;\n      [node, offset] = leaf.position(offset, true);\n      range.setEnd(node, offset);\n      return range.getBoundingClientRect();\n    } else {\n      let side = 'left';\n      let rect;\n      if (node instanceof Text) {\n        if (offset < node.data.length) {\n          range.setStart(node, offset);\n          range.setEnd(node, offset + 1);\n        } else {\n          range.setStart(node, offset - 1);\n          range.setEnd(node, offset);\n          side = 'right';\n        }\n        rect = range.getBoundingClientRect();\n      } else {\n        rect = leaf.domNode.getBoundingClientRect();\n        if (offset > 0) side = 'right';\n      }\n      return {\n        bottom: rect.top + rect.height,\n        height: rect.height,\n        left: rect[side],\n        right: rect[side],\n        top: rect.top,\n        width: 0\n      };\n    }\n  }\n\n  getNativeRange() {\n    let selection = document.getSelection();\n    if (selection == null || selection.rangeCount <= 0) return null;\n    let nativeRange = selection.getRangeAt(0);\n    if (nativeRange == null) return null;\n    let range = this.normalizeNative(nativeRange);\n    debug.info('getNativeRange', range);\n    return range;\n  }\n\n  getRange() {\n    let normalized = this.getNativeRange();\n    if (normalized == null) return [null, null];\n    let range = this.normalizedToRange(normalized);\n    return [range, normalized];\n  }\n\n  hasFocus() {\n    return document.activeElement === this.root;\n  }\n\n  normalizedToRange(range) {\n    let positions = [[range.start.node, range.start.offset]];\n    if (!range.native.collapsed) {\n      positions.push([range.end.node, range.end.offset]);\n    }\n    let indexes = positions.map((position) => {\n      let [node, offset] = position;\n      let blot = Parchment.find(node, true);\n      let index = blot.offset(this.scroll);\n      if (offset === 0) {\n        return index;\n      } else if (blot instanceof Parchment.Container) {\n        return index + blot.length();\n      } else {\n        return index + blot.index(node, offset);\n      }\n    });\n    let end = Math.min(Math.max(...indexes), this.scroll.length() - 1);\n    let start = Math.min(end, ...indexes);\n    return new Range(start, end-start);\n  }\n\n  normalizeNative(nativeRange) {\n    if (!contains(this.root, nativeRange.startContainer) ||\n        (!nativeRange.collapsed && !contains(this.root, nativeRange.endContainer))) {\n      return null;\n    }\n    let range = {\n      start: { node: nativeRange.startContainer, offset: nativeRange.startOffset },\n      end: { node: nativeRange.endContainer, offset: nativeRange.endOffset },\n      native: nativeRange\n    };\n    [range.start, range.end].forEach(function(position) {\n      let node = position.node, offset = position.offset;\n      while (!(node instanceof Text) && node.childNodes.length > 0) {\n        if (node.childNodes.length > offset) {\n          node = node.childNodes[offset];\n          offset = 0;\n        } else if (node.childNodes.length === offset) {\n          node = node.lastChild;\n          offset = node instanceof Text ? node.data.length : node.childNodes.length + 1;\n        } else {\n          break;\n        }\n      }\n      position.node = node, position.offset = offset;\n    });\n    return range;\n  }\n\n  rangeToNative(range) {\n    let indexes = range.collapsed ? [range.index] : [range.index, range.index + range.length];\n    let args = [];\n    let scrollLength = this.scroll.length();\n    indexes.forEach((index, i) => {\n      index = Math.min(scrollLength - 1, index);\n      let node, [leaf, offset] = this.scroll.leaf(index);\n      [node, offset] = leaf.position(offset, i !== 0);\n      args.push(node, offset);\n    });\n    if (args.length < 2) {\n      args = args.concat(args);\n    }\n    return args;\n  }\n\n  scrollIntoView(scrollingContainer) {\n    let range = this.lastRange;\n    if (range == null) return;\n    let bounds = this.getBounds(range.index, range.length);\n    if (bounds == null) return;\n    let limit = this.scroll.length()-1;\n    let [first, ] = this.scroll.line(Math.min(range.index, limit));\n    let last = first;\n    if (range.length > 0) {\n      [last, ] = this.scroll.line(Math.min(range.index + range.length, limit));\n    }\n    if (first == null || last == null) return;\n    let scrollBounds = scrollingContainer.getBoundingClientRect();\n    if (bounds.top < scrollBounds.top) {\n      scrollingContainer.scrollTop -= (scrollBounds.top - bounds.top);\n    } else if (bounds.bottom > scrollBounds.bottom) {\n      scrollingContainer.scrollTop += (bounds.bottom - scrollBounds.bottom);\n    }\n  }\n\n  setNativeRange(startNode, startOffset, endNode = startNode, endOffset = startOffset, force = false) {\n    debug.info('setNativeRange', startNode, startOffset, endNode, endOffset);\n    if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {\n      return;\n    }\n    let selection = document.getSelection();\n    if (selection == null) return;\n    if (startNode != null) {\n      if (!this.hasFocus()) this.root.focus();\n      let native = (this.getNativeRange() || {}).native;\n      if (native == null || force ||\n          startNode !== native.startContainer ||\n          startOffset !== native.startOffset ||\n          endNode !== native.endContainer ||\n          endOffset !== native.endOffset) {\n\n        if (startNode.tagName == \"BR\") {\n          startOffset = [].indexOf.call(startNode.parentNode.childNodes, startNode);\n          startNode = startNode.parentNode;\n        }\n        if (endNode.tagName == \"BR\") {\n          endOffset = [].indexOf.call(endNode.parentNode.childNodes, endNode);\n          endNode = endNode.parentNode;\n        }\n        let range = document.createRange();\n        range.setStart(startNode, startOffset);\n        range.setEnd(endNode, endOffset);\n        selection.removeAllRanges();\n        selection.addRange(range);\n      }\n    } else {\n      selection.removeAllRanges();\n      this.root.blur();\n      document.body.focus();  // root.blur() not enough on IE11+Travis+SauceLabs (but not local VMs)\n    }\n  }\n\n  setRange(range, force = false, source = Emitter.sources.API) {\n    if (typeof force === 'string') {\n      source = force;\n      force = false;\n    }\n    debug.info('setRange', range);\n    if (range != null) {\n      let args = this.rangeToNative(range);\n      this.setNativeRange(...args, force);\n    } else {\n      this.setNativeRange(null);\n    }\n    this.update(source);\n  }\n\n  update(source = Emitter.sources.USER) {\n    let oldRange = this.lastRange;\n    let [lastRange, nativeRange] = this.getRange();\n    this.lastRange = lastRange;\n    if (this.lastRange != null) {\n      this.savedRange = this.lastRange;\n    }\n    if (!equal(oldRange, this.lastRange)) {\n      if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {\n        this.cursor.restore();\n      }\n      let args = [Emitter.events.SELECTION_CHANGE, clone(this.lastRange), clone(oldRange), source];\n      this.emitter.emit(Emitter.events.EDITOR_CHANGE, ...args);\n      if (source !== Emitter.sources.SILENT) {\n        this.emitter.emit(...args);\n      }\n    }\n  }\n}\n\n\nfunction contains(parent, descendant) {\n  try {\n    // Firefox inserts inaccessible nodes around video elements\n    descendant.parentNode;\n  } catch (e) {\n    return false;\n  }\n  // IE11 has bug with Text nodes\n  // https://connect.microsoft.com/IE/feedback/details/780874/node-contains-is-incorrect\n  if (descendant instanceof Text) {\n    descendant = descendant.parentNode;\n  }\n  return parent.contains(descendant);\n}\n\n\nexport { Range, Selection as default };\n"]},"metadata":{},"sourceType":"module"}