{"ast":null,"code":"import extend from 'extend';\nimport Delta from 'quill-delta';\nimport Parchment from 'parchment';\nimport Break from './break';\nimport Inline from './inline';\nimport TextBlot from './text';\nconst NEWLINE_LENGTH = 1;\n\nclass BlockEmbed extends Parchment.Embed {\n  attach() {\n    super.attach();\n    this.attributes = new Parchment.Attributor.Store(this.domNode);\n  }\n\n  delta() {\n    return new Delta().insert(this.value(), extend(this.formats(), this.attributes.values()));\n  }\n\n  format(name, value) {\n    let attribute = Parchment.query(name, Parchment.Scope.BLOCK_ATTRIBUTE);\n\n    if (attribute != null) {\n      this.attributes.attribute(attribute, value);\n    }\n  }\n\n  formatAt(index, length, name, value) {\n    this.format(name, value);\n  }\n\n  insertAt(index, value, def) {\n    if (typeof value === 'string' && value.endsWith('\\n')) {\n      let block = Parchment.create(Block.blotName);\n      this.parent.insertBefore(block, index === 0 ? this : this.next);\n      block.insertAt(0, value.slice(0, -1));\n    } else {\n      super.insertAt(index, value, def);\n    }\n  }\n\n}\n\nBlockEmbed.scope = Parchment.Scope.BLOCK_BLOT; // It is important for cursor behavior BlockEmbeds use tags that are block level elements\n\nclass Block extends Parchment.Block {\n  constructor(domNode) {\n    super(domNode);\n    this.cache = {};\n  }\n\n  delta() {\n    if (this.cache.delta == null) {\n      this.cache.delta = this.descendants(Parchment.Leaf).reduce((delta, leaf) => {\n        if (leaf.length() === 0) {\n          return delta;\n        } else {\n          return delta.insert(leaf.value(), bubbleFormats(leaf));\n        }\n      }, new Delta()).insert('\\n', bubbleFormats(this));\n    }\n\n    return this.cache.delta;\n  }\n\n  deleteAt(index, length) {\n    super.deleteAt(index, length);\n    this.cache = {};\n  }\n\n  formatAt(index, length, name, value) {\n    if (length <= 0) return;\n\n    if (Parchment.query(name, Parchment.Scope.BLOCK)) {\n      if (index + length === this.length()) {\n        this.format(name, value);\n      }\n    } else {\n      super.formatAt(index, Math.min(length, this.length() - index - 1), name, value);\n    }\n\n    this.cache = {};\n  }\n\n  insertAt(index, value, def) {\n    if (def != null) return super.insertAt(index, value, def);\n    if (value.length === 0) return;\n    let lines = value.split('\\n');\n    let text = lines.shift();\n\n    if (text.length > 0) {\n      if (index < this.length() - 1 || this.children.tail == null) {\n        super.insertAt(Math.min(index, this.length() - 1), text);\n      } else {\n        this.children.tail.insertAt(this.children.tail.length(), text);\n      }\n\n      this.cache = {};\n    }\n\n    let block = this;\n    lines.reduce(function (index, line) {\n      block = block.split(index, true);\n      block.insertAt(0, line);\n      return line.length;\n    }, index + text.length);\n  }\n\n  insertBefore(blot, ref) {\n    let head = this.children.head;\n    super.insertBefore(blot, ref);\n\n    if (head instanceof Break) {\n      head.remove();\n    }\n\n    this.cache = {};\n  }\n\n  length() {\n    if (this.cache.length == null) {\n      this.cache.length = super.length() + NEWLINE_LENGTH;\n    }\n\n    return this.cache.length;\n  }\n\n  moveChildren(target, ref) {\n    super.moveChildren(target, ref);\n    this.cache = {};\n  }\n\n  optimize(context) {\n    super.optimize(context);\n    this.cache = {};\n  }\n\n  path(index) {\n    return super.path(index, true);\n  }\n\n  removeChild(child) {\n    super.removeChild(child);\n    this.cache = {};\n  }\n\n  split(index, force = false) {\n    if (force && (index === 0 || index >= this.length() - NEWLINE_LENGTH)) {\n      let clone = this.clone();\n\n      if (index === 0) {\n        this.parent.insertBefore(clone, this);\n        return this;\n      } else {\n        this.parent.insertBefore(clone, this.next);\n        return clone;\n      }\n    } else {\n      let next = super.split(index, force);\n      this.cache = {};\n      return next;\n    }\n  }\n\n}\n\nBlock.blotName = 'block';\nBlock.tagName = 'P';\nBlock.defaultChild = 'break';\nBlock.allowedChildren = [Inline, Parchment.Embed, TextBlot];\n\nfunction bubbleFormats(blot, formats = {}) {\n  if (blot == null) return formats;\n\n  if (typeof blot.formats === 'function') {\n    formats = extend(formats, blot.formats());\n  }\n\n  if (blot.parent == null || blot.parent.blotName == 'scroll' || blot.parent.statics.scope !== blot.statics.scope) {\n    return formats;\n  }\n\n  return bubbleFormats(blot.parent, formats);\n}\n\nexport { bubbleFormats, BlockEmbed, Block as default };","map":{"version":3,"sources":["/home/thatguy/My-repos/Javascript/React/docs-clone/client/node_modules/quill/blots/block.js"],"names":["extend","Delta","Parchment","Break","Inline","TextBlot","NEWLINE_LENGTH","BlockEmbed","Embed","attach","attributes","Attributor","Store","domNode","delta","insert","value","formats","values","format","name","attribute","query","Scope","BLOCK_ATTRIBUTE","formatAt","index","length","insertAt","def","endsWith","block","create","Block","blotName","parent","insertBefore","next","slice","scope","BLOCK_BLOT","constructor","cache","descendants","Leaf","reduce","leaf","bubbleFormats","deleteAt","BLOCK","Math","min","lines","split","text","shift","children","tail","line","blot","ref","head","remove","moveChildren","target","optimize","context","path","removeChild","child","force","clone","tagName","defaultChild","allowedChildren","statics","default"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,QAAnB;AACA,OAAOC,KAAP,MAAkB,aAAlB;AACA,OAAOC,SAAP,MAAsB,WAAtB;AACA,OAAOC,KAAP,MAAkB,SAAlB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AACA,OAAOC,QAAP,MAAqB,QAArB;AAGA,MAAMC,cAAc,GAAG,CAAvB;;AAGA,MAAMC,UAAN,SAAyBL,SAAS,CAACM,KAAnC,CAAyC;AACvCC,EAAAA,MAAM,GAAG;AACP,UAAMA,MAAN;AACA,SAAKC,UAAL,GAAkB,IAAIR,SAAS,CAACS,UAAV,CAAqBC,KAAzB,CAA+B,KAAKC,OAApC,CAAlB;AACD;;AAEDC,EAAAA,KAAK,GAAG;AACN,WAAO,IAAIb,KAAJ,GAAYc,MAAZ,CAAmB,KAAKC,KAAL,EAAnB,EAAiChB,MAAM,CAAC,KAAKiB,OAAL,EAAD,EAAiB,KAAKP,UAAL,CAAgBQ,MAAhB,EAAjB,CAAvC,CAAP;AACD;;AAEDC,EAAAA,MAAM,CAACC,IAAD,EAAOJ,KAAP,EAAc;AAClB,QAAIK,SAAS,GAAGnB,SAAS,CAACoB,KAAV,CAAgBF,IAAhB,EAAsBlB,SAAS,CAACqB,KAAV,CAAgBC,eAAtC,CAAhB;;AACA,QAAIH,SAAS,IAAI,IAAjB,EAAuB;AACrB,WAAKX,UAAL,CAAgBW,SAAhB,CAA0BA,SAA1B,EAAqCL,KAArC;AACD;AACF;;AAEDS,EAAAA,QAAQ,CAACC,KAAD,EAAQC,MAAR,EAAgBP,IAAhB,EAAsBJ,KAAtB,EAA6B;AACnC,SAAKG,MAAL,CAAYC,IAAZ,EAAkBJ,KAAlB;AACD;;AAEDY,EAAAA,QAAQ,CAACF,KAAD,EAAQV,KAAR,EAAea,GAAf,EAAoB;AAC1B,QAAI,OAAOb,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAACc,QAAN,CAAe,IAAf,CAAjC,EAAuD;AACrD,UAAIC,KAAK,GAAG7B,SAAS,CAAC8B,MAAV,CAAiBC,KAAK,CAACC,QAAvB,CAAZ;AACA,WAAKC,MAAL,CAAYC,YAAZ,CAAyBL,KAAzB,EAAgCL,KAAK,KAAK,CAAV,GAAc,IAAd,GAAqB,KAAKW,IAA1D;AACAN,MAAAA,KAAK,CAACH,QAAN,CAAe,CAAf,EAAkBZ,KAAK,CAACsB,KAAN,CAAY,CAAZ,EAAe,CAAC,CAAhB,CAAlB;AACD,KAJD,MAIO;AACL,YAAMV,QAAN,CAAeF,KAAf,EAAsBV,KAAtB,EAA6Ba,GAA7B;AACD;AACF;;AA7BsC;;AA+BzCtB,UAAU,CAACgC,KAAX,GAAmBrC,SAAS,CAACqB,KAAV,CAAgBiB,UAAnC,C,CACA;;AAGA,MAAMP,KAAN,SAAoB/B,SAAS,CAAC+B,KAA9B,CAAoC;AAClCQ,EAAAA,WAAW,CAAC5B,OAAD,EAAU;AACnB,UAAMA,OAAN;AACA,SAAK6B,KAAL,GAAa,EAAb;AACD;;AAED5B,EAAAA,KAAK,GAAG;AACN,QAAI,KAAK4B,KAAL,CAAW5B,KAAX,IAAoB,IAAxB,EAA8B;AAC5B,WAAK4B,KAAL,CAAW5B,KAAX,GAAmB,KAAK6B,WAAL,CAAiBzC,SAAS,CAAC0C,IAA3B,EAAiCC,MAAjC,CAAwC,CAAC/B,KAAD,EAAQgC,IAAR,KAAiB;AAC1E,YAAIA,IAAI,CAACnB,MAAL,OAAkB,CAAtB,EAAyB;AACvB,iBAAOb,KAAP;AACD,SAFD,MAEO;AACL,iBAAOA,KAAK,CAACC,MAAN,CAAa+B,IAAI,CAAC9B,KAAL,EAAb,EAA2B+B,aAAa,CAACD,IAAD,CAAxC,CAAP;AACD;AACF,OANkB,EAMhB,IAAI7C,KAAJ,EANgB,EAMHc,MANG,CAMI,IANJ,EAMUgC,aAAa,CAAC,IAAD,CANvB,CAAnB;AAOD;;AACD,WAAO,KAAKL,KAAL,CAAW5B,KAAlB;AACD;;AAEDkC,EAAAA,QAAQ,CAACtB,KAAD,EAAQC,MAAR,EAAgB;AACtB,UAAMqB,QAAN,CAAetB,KAAf,EAAsBC,MAAtB;AACA,SAAKe,KAAL,GAAa,EAAb;AACD;;AAEDjB,EAAAA,QAAQ,CAACC,KAAD,EAAQC,MAAR,EAAgBP,IAAhB,EAAsBJ,KAAtB,EAA6B;AACnC,QAAIW,MAAM,IAAI,CAAd,EAAiB;;AACjB,QAAIzB,SAAS,CAACoB,KAAV,CAAgBF,IAAhB,EAAsBlB,SAAS,CAACqB,KAAV,CAAgB0B,KAAtC,CAAJ,EAAkD;AAChD,UAAIvB,KAAK,GAAGC,MAAR,KAAmB,KAAKA,MAAL,EAAvB,EAAsC;AACpC,aAAKR,MAAL,CAAYC,IAAZ,EAAkBJ,KAAlB;AACD;AACF,KAJD,MAIO;AACL,YAAMS,QAAN,CAAeC,KAAf,EAAsBwB,IAAI,CAACC,GAAL,CAASxB,MAAT,EAAiB,KAAKA,MAAL,KAAgBD,KAAhB,GAAwB,CAAzC,CAAtB,EAAmEN,IAAnE,EAAyEJ,KAAzE;AACD;;AACD,SAAK0B,KAAL,GAAa,EAAb;AACD;;AAEDd,EAAAA,QAAQ,CAACF,KAAD,EAAQV,KAAR,EAAea,GAAf,EAAoB;AAC1B,QAAIA,GAAG,IAAI,IAAX,EAAiB,OAAO,MAAMD,QAAN,CAAeF,KAAf,EAAsBV,KAAtB,EAA6Ba,GAA7B,CAAP;AACjB,QAAIb,KAAK,CAACW,MAAN,KAAiB,CAArB,EAAwB;AACxB,QAAIyB,KAAK,GAAGpC,KAAK,CAACqC,KAAN,CAAY,IAAZ,CAAZ;AACA,QAAIC,IAAI,GAAGF,KAAK,CAACG,KAAN,EAAX;;AACA,QAAID,IAAI,CAAC3B,MAAL,GAAc,CAAlB,EAAqB;AACnB,UAAID,KAAK,GAAG,KAAKC,MAAL,KAAgB,CAAxB,IAA6B,KAAK6B,QAAL,CAAcC,IAAd,IAAsB,IAAvD,EAA6D;AAC3D,cAAM7B,QAAN,CAAesB,IAAI,CAACC,GAAL,CAASzB,KAAT,EAAgB,KAAKC,MAAL,KAAgB,CAAhC,CAAf,EAAmD2B,IAAnD;AACD,OAFD,MAEO;AACL,aAAKE,QAAL,CAAcC,IAAd,CAAmB7B,QAAnB,CAA4B,KAAK4B,QAAL,CAAcC,IAAd,CAAmB9B,MAAnB,EAA5B,EAAyD2B,IAAzD;AACD;;AACD,WAAKZ,KAAL,GAAa,EAAb;AACD;;AACD,QAAIX,KAAK,GAAG,IAAZ;AACAqB,IAAAA,KAAK,CAACP,MAAN,CAAa,UAASnB,KAAT,EAAgBgC,IAAhB,EAAsB;AACjC3B,MAAAA,KAAK,GAAGA,KAAK,CAACsB,KAAN,CAAY3B,KAAZ,EAAmB,IAAnB,CAAR;AACAK,MAAAA,KAAK,CAACH,QAAN,CAAe,CAAf,EAAkB8B,IAAlB;AACA,aAAOA,IAAI,CAAC/B,MAAZ;AACD,KAJD,EAIGD,KAAK,GAAG4B,IAAI,CAAC3B,MAJhB;AAKD;;AAEDS,EAAAA,YAAY,CAACuB,IAAD,EAAOC,GAAP,EAAY;AACtB,QAAIC,IAAI,GAAG,KAAKL,QAAL,CAAcK,IAAzB;AACA,UAAMzB,YAAN,CAAmBuB,IAAnB,EAAyBC,GAAzB;;AACA,QAAIC,IAAI,YAAY1D,KAApB,EAA2B;AACzB0D,MAAAA,IAAI,CAACC,MAAL;AACD;;AACD,SAAKpB,KAAL,GAAa,EAAb;AACD;;AAEDf,EAAAA,MAAM,GAAG;AACP,QAAI,KAAKe,KAAL,CAAWf,MAAX,IAAqB,IAAzB,EAA+B;AAC7B,WAAKe,KAAL,CAAWf,MAAX,GAAoB,MAAMA,MAAN,KAAiBrB,cAArC;AACD;;AACD,WAAO,KAAKoC,KAAL,CAAWf,MAAlB;AACD;;AAEDoC,EAAAA,YAAY,CAACC,MAAD,EAASJ,GAAT,EAAc;AACxB,UAAMG,YAAN,CAAmBC,MAAnB,EAA2BJ,GAA3B;AACA,SAAKlB,KAAL,GAAa,EAAb;AACD;;AAEDuB,EAAAA,QAAQ,CAACC,OAAD,EAAU;AAChB,UAAMD,QAAN,CAAeC,OAAf;AACA,SAAKxB,KAAL,GAAa,EAAb;AACD;;AAEDyB,EAAAA,IAAI,CAACzC,KAAD,EAAQ;AACV,WAAO,MAAMyC,IAAN,CAAWzC,KAAX,EAAkB,IAAlB,CAAP;AACD;;AAED0C,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACjB,UAAMD,WAAN,CAAkBC,KAAlB;AACA,SAAK3B,KAAL,GAAa,EAAb;AACD;;AAEDW,EAAAA,KAAK,CAAC3B,KAAD,EAAQ4C,KAAK,GAAG,KAAhB,EAAuB;AAC1B,QAAIA,KAAK,KAAK5C,KAAK,KAAK,CAAV,IAAeA,KAAK,IAAI,KAAKC,MAAL,KAAgBrB,cAA7C,CAAT,EAAuE;AACrE,UAAIiE,KAAK,GAAG,KAAKA,KAAL,EAAZ;;AACA,UAAI7C,KAAK,KAAK,CAAd,EAAiB;AACf,aAAKS,MAAL,CAAYC,YAAZ,CAAyBmC,KAAzB,EAAgC,IAAhC;AACA,eAAO,IAAP;AACD,OAHD,MAGO;AACL,aAAKpC,MAAL,CAAYC,YAAZ,CAAyBmC,KAAzB,EAAgC,KAAKlC,IAArC;AACA,eAAOkC,KAAP;AACD;AACF,KATD,MASO;AACL,UAAIlC,IAAI,GAAG,MAAMgB,KAAN,CAAY3B,KAAZ,EAAmB4C,KAAnB,CAAX;AACA,WAAK5B,KAAL,GAAa,EAAb;AACA,aAAOL,IAAP;AACD;AACF;;AA3GiC;;AA6GpCJ,KAAK,CAACC,QAAN,GAAiB,OAAjB;AACAD,KAAK,CAACuC,OAAN,GAAgB,GAAhB;AACAvC,KAAK,CAACwC,YAAN,GAAqB,OAArB;AACAxC,KAAK,CAACyC,eAAN,GAAwB,CAACtE,MAAD,EAASF,SAAS,CAACM,KAAnB,EAA0BH,QAA1B,CAAxB;;AAGA,SAAS0C,aAAT,CAAuBY,IAAvB,EAA6B1C,OAAO,GAAG,EAAvC,EAA2C;AACzC,MAAI0C,IAAI,IAAI,IAAZ,EAAkB,OAAO1C,OAAP;;AAClB,MAAI,OAAO0C,IAAI,CAAC1C,OAAZ,KAAwB,UAA5B,EAAwC;AACtCA,IAAAA,OAAO,GAAGjB,MAAM,CAACiB,OAAD,EAAU0C,IAAI,CAAC1C,OAAL,EAAV,CAAhB;AACD;;AACD,MAAI0C,IAAI,CAACxB,MAAL,IAAe,IAAf,IAAuBwB,IAAI,CAACxB,MAAL,CAAYD,QAAZ,IAAwB,QAA/C,IAA2DyB,IAAI,CAACxB,MAAL,CAAYwC,OAAZ,CAAoBpC,KAApB,KAA8BoB,IAAI,CAACgB,OAAL,CAAapC,KAA1G,EAAiH;AAC/G,WAAOtB,OAAP;AACD;;AACD,SAAO8B,aAAa,CAACY,IAAI,CAACxB,MAAN,EAAclB,OAAd,CAApB;AACD;;AAGD,SAAS8B,aAAT,EAAwBxC,UAAxB,EAAoC0B,KAAK,IAAI2C,OAA7C","sourcesContent":["import extend from 'extend';\nimport Delta from 'quill-delta';\nimport Parchment from 'parchment';\nimport Break from './break';\nimport Inline from './inline';\nimport TextBlot from './text';\n\n\nconst NEWLINE_LENGTH = 1;\n\n\nclass BlockEmbed extends Parchment.Embed {\n  attach() {\n    super.attach();\n    this.attributes = new Parchment.Attributor.Store(this.domNode);\n  }\n\n  delta() {\n    return new Delta().insert(this.value(), extend(this.formats(), this.attributes.values()));\n  }\n\n  format(name, value) {\n    let attribute = Parchment.query(name, Parchment.Scope.BLOCK_ATTRIBUTE);\n    if (attribute != null) {\n      this.attributes.attribute(attribute, value);\n    }\n  }\n\n  formatAt(index, length, name, value) {\n    this.format(name, value);\n  }\n\n  insertAt(index, value, def) {\n    if (typeof value === 'string' && value.endsWith('\\n')) {\n      let block = Parchment.create(Block.blotName);\n      this.parent.insertBefore(block, index === 0 ? this : this.next);\n      block.insertAt(0, value.slice(0, -1));\n    } else {\n      super.insertAt(index, value, def);\n    }\n  }\n}\nBlockEmbed.scope = Parchment.Scope.BLOCK_BLOT;\n// It is important for cursor behavior BlockEmbeds use tags that are block level elements\n\n\nclass Block extends Parchment.Block {\n  constructor(domNode) {\n    super(domNode);\n    this.cache = {};\n  }\n\n  delta() {\n    if (this.cache.delta == null) {\n      this.cache.delta = this.descendants(Parchment.Leaf).reduce((delta, leaf) => {\n        if (leaf.length() === 0) {\n          return delta;\n        } else {\n          return delta.insert(leaf.value(), bubbleFormats(leaf));\n        }\n      }, new Delta()).insert('\\n', bubbleFormats(this));\n    }\n    return this.cache.delta;\n  }\n\n  deleteAt(index, length) {\n    super.deleteAt(index, length);\n    this.cache = {};\n  }\n\n  formatAt(index, length, name, value) {\n    if (length <= 0) return;\n    if (Parchment.query(name, Parchment.Scope.BLOCK)) {\n      if (index + length === this.length()) {\n        this.format(name, value);\n      }\n    } else {\n      super.formatAt(index, Math.min(length, this.length() - index - 1), name, value);\n    }\n    this.cache = {};\n  }\n\n  insertAt(index, value, def) {\n    if (def != null) return super.insertAt(index, value, def);\n    if (value.length === 0) return;\n    let lines = value.split('\\n');\n    let text = lines.shift();\n    if (text.length > 0) {\n      if (index < this.length() - 1 || this.children.tail == null) {\n        super.insertAt(Math.min(index, this.length() - 1), text);\n      } else {\n        this.children.tail.insertAt(this.children.tail.length(), text);\n      }\n      this.cache = {};\n    }\n    let block = this;\n    lines.reduce(function(index, line) {\n      block = block.split(index, true);\n      block.insertAt(0, line);\n      return line.length;\n    }, index + text.length);\n  }\n\n  insertBefore(blot, ref) {\n    let head = this.children.head;\n    super.insertBefore(blot, ref);\n    if (head instanceof Break) {\n      head.remove();\n    }\n    this.cache = {};\n  }\n\n  length() {\n    if (this.cache.length == null) {\n      this.cache.length = super.length() + NEWLINE_LENGTH;\n    }\n    return this.cache.length;\n  }\n\n  moveChildren(target, ref) {\n    super.moveChildren(target, ref);\n    this.cache = {};\n  }\n\n  optimize(context) {\n    super.optimize(context);\n    this.cache = {};\n  }\n\n  path(index) {\n    return super.path(index, true);\n  }\n\n  removeChild(child) {\n    super.removeChild(child);\n    this.cache = {};\n  }\n\n  split(index, force = false) {\n    if (force && (index === 0 || index >= this.length() - NEWLINE_LENGTH)) {\n      let clone = this.clone();\n      if (index === 0) {\n        this.parent.insertBefore(clone, this);\n        return this;\n      } else {\n        this.parent.insertBefore(clone, this.next);\n        return clone;\n      }\n    } else {\n      let next = super.split(index, force);\n      this.cache = {};\n      return next;\n    }\n  }\n}\nBlock.blotName = 'block';\nBlock.tagName = 'P';\nBlock.defaultChild = 'break';\nBlock.allowedChildren = [Inline, Parchment.Embed, TextBlot];\n\n\nfunction bubbleFormats(blot, formats = {}) {\n  if (blot == null) return formats;\n  if (typeof blot.formats === 'function') {\n    formats = extend(formats, blot.formats());\n  }\n  if (blot.parent == null || blot.parent.blotName == 'scroll' || blot.parent.statics.scope !== blot.statics.scope) {\n    return formats;\n  }\n  return bubbleFormats(blot.parent, formats);\n}\n\n\nexport { bubbleFormats, BlockEmbed, Block as default };\n"]},"metadata":{},"sourceType":"module"}