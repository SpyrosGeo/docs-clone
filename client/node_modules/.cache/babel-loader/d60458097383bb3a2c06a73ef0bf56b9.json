{"ast":null,"code":"var diff = require('fast-diff');\n\nvar equal = require('deep-equal');\n\nvar extend = require('extend');\n\nvar op = require('./op');\n\nvar NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()\n\nvar Delta = function (ops) {\n  // Assume we are given a well formed ops\n  if (Array.isArray(ops)) {\n    this.ops = ops;\n  } else if (ops != null && Array.isArray(ops.ops)) {\n    this.ops = ops.ops;\n  } else {\n    this.ops = [];\n  }\n};\n\nDelta.prototype.insert = function (text, attributes) {\n  var newOp = {};\n  if (text.length === 0) return this;\n  newOp.insert = text;\n\n  if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {\n    newOp.attributes = attributes;\n  }\n\n  return this.push(newOp);\n};\n\nDelta.prototype['delete'] = function (length) {\n  if (length <= 0) return this;\n  return this.push({\n    'delete': length\n  });\n};\n\nDelta.prototype.retain = function (length, attributes) {\n  if (length <= 0) return this;\n  var newOp = {\n    retain: length\n  };\n\n  if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {\n    newOp.attributes = attributes;\n  }\n\n  return this.push(newOp);\n};\n\nDelta.prototype.push = function (newOp) {\n  var index = this.ops.length;\n  var lastOp = this.ops[index - 1];\n  newOp = extend(true, {}, newOp);\n\n  if (typeof lastOp === 'object') {\n    if (typeof newOp['delete'] === 'number' && typeof lastOp['delete'] === 'number') {\n      this.ops[index - 1] = {\n        'delete': lastOp['delete'] + newOp['delete']\n      };\n      return this;\n    } // Since it does not matter if we insert before or after deleting at the same index,\n    // always prefer to insert first\n\n\n    if (typeof lastOp['delete'] === 'number' && newOp.insert != null) {\n      index -= 1;\n      lastOp = this.ops[index - 1];\n\n      if (typeof lastOp !== 'object') {\n        this.ops.unshift(newOp);\n        return this;\n      }\n    }\n\n    if (equal(newOp.attributes, lastOp.attributes)) {\n      if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {\n        this.ops[index - 1] = {\n          insert: lastOp.insert + newOp.insert\n        };\n        if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes;\n        return this;\n      } else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {\n        this.ops[index - 1] = {\n          retain: lastOp.retain + newOp.retain\n        };\n        if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes;\n        return this;\n      }\n    }\n  }\n\n  if (index === this.ops.length) {\n    this.ops.push(newOp);\n  } else {\n    this.ops.splice(index, 0, newOp);\n  }\n\n  return this;\n};\n\nDelta.prototype.chop = function () {\n  var lastOp = this.ops[this.ops.length - 1];\n\n  if (lastOp && lastOp.retain && !lastOp.attributes) {\n    this.ops.pop();\n  }\n\n  return this;\n};\n\nDelta.prototype.filter = function (predicate) {\n  return this.ops.filter(predicate);\n};\n\nDelta.prototype.forEach = function (predicate) {\n  this.ops.forEach(predicate);\n};\n\nDelta.prototype.map = function (predicate) {\n  return this.ops.map(predicate);\n};\n\nDelta.prototype.partition = function (predicate) {\n  var passed = [],\n      failed = [];\n  this.forEach(function (op) {\n    var target = predicate(op) ? passed : failed;\n    target.push(op);\n  });\n  return [passed, failed];\n};\n\nDelta.prototype.reduce = function (predicate, initial) {\n  return this.ops.reduce(predicate, initial);\n};\n\nDelta.prototype.changeLength = function () {\n  return this.reduce(function (length, elem) {\n    if (elem.insert) {\n      return length + op.length(elem);\n    } else if (elem.delete) {\n      return length - elem.delete;\n    }\n\n    return length;\n  }, 0);\n};\n\nDelta.prototype.length = function () {\n  return this.reduce(function (length, elem) {\n    return length + op.length(elem);\n  }, 0);\n};\n\nDelta.prototype.slice = function (start, end) {\n  start = start || 0;\n  if (typeof end !== 'number') end = Infinity;\n  var ops = [];\n  var iter = op.iterator(this.ops);\n  var index = 0;\n\n  while (index < end && iter.hasNext()) {\n    var nextOp;\n\n    if (index < start) {\n      nextOp = iter.next(start - index);\n    } else {\n      nextOp = iter.next(end - index);\n      ops.push(nextOp);\n    }\n\n    index += op.length(nextOp);\n  }\n\n  return new Delta(ops);\n};\n\nDelta.prototype.compose = function (other) {\n  var thisIter = op.iterator(this.ops);\n  var otherIter = op.iterator(other.ops);\n  var ops = [];\n  var firstOther = otherIter.peek();\n\n  if (firstOther != null && typeof firstOther.retain === 'number' && firstOther.attributes == null) {\n    var firstLeft = firstOther.retain;\n\n    while (thisIter.peekType() === 'insert' && thisIter.peekLength() <= firstLeft) {\n      firstLeft -= thisIter.peekLength();\n      ops.push(thisIter.next());\n    }\n\n    if (firstOther.retain - firstLeft > 0) {\n      otherIter.next(firstOther.retain - firstLeft);\n    }\n  }\n\n  var delta = new Delta(ops);\n\n  while (thisIter.hasNext() || otherIter.hasNext()) {\n    if (otherIter.peekType() === 'insert') {\n      delta.push(otherIter.next());\n    } else if (thisIter.peekType() === 'delete') {\n      delta.push(thisIter.next());\n    } else {\n      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n      var thisOp = thisIter.next(length);\n      var otherOp = otherIter.next(length);\n\n      if (typeof otherOp.retain === 'number') {\n        var newOp = {};\n\n        if (typeof thisOp.retain === 'number') {\n          newOp.retain = length;\n        } else {\n          newOp.insert = thisOp.insert;\n        } // Preserve null when composing with a retain, otherwise remove it for inserts\n\n\n        var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');\n        if (attributes) newOp.attributes = attributes;\n        delta.push(newOp); // Optimization if rest of other is just retain\n\n        if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {\n          var rest = new Delta(thisIter.rest());\n          return delta.concat(rest).chop();\n        } // Other op should be delete, we could be an insert or retain\n        // Insert + delete cancels out\n\n      } else if (typeof otherOp['delete'] === 'number' && typeof thisOp.retain === 'number') {\n        delta.push(otherOp);\n      }\n    }\n  }\n\n  return delta.chop();\n};\n\nDelta.prototype.concat = function (other) {\n  var delta = new Delta(this.ops.slice());\n\n  if (other.ops.length > 0) {\n    delta.push(other.ops[0]);\n    delta.ops = delta.ops.concat(other.ops.slice(1));\n  }\n\n  return delta;\n};\n\nDelta.prototype.diff = function (other, index) {\n  if (this.ops === other.ops) {\n    return new Delta();\n  }\n\n  var strings = [this, other].map(function (delta) {\n    return delta.map(function (op) {\n      if (op.insert != null) {\n        return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;\n      }\n\n      var prep = delta === other ? 'on' : 'with';\n      throw new Error('diff() called ' + prep + ' non-document');\n    }).join('');\n  });\n  var delta = new Delta();\n  var diffResult = diff(strings[0], strings[1], index);\n  var thisIter = op.iterator(this.ops);\n  var otherIter = op.iterator(other.ops);\n  diffResult.forEach(function (component) {\n    var length = component[1].length;\n\n    while (length > 0) {\n      var opLength = 0;\n\n      switch (component[0]) {\n        case diff.INSERT:\n          opLength = Math.min(otherIter.peekLength(), length);\n          delta.push(otherIter.next(opLength));\n          break;\n\n        case diff.DELETE:\n          opLength = Math.min(length, thisIter.peekLength());\n          thisIter.next(opLength);\n          delta['delete'](opLength);\n          break;\n\n        case diff.EQUAL:\n          opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);\n          var thisOp = thisIter.next(opLength);\n          var otherOp = otherIter.next(opLength);\n\n          if (equal(thisOp.insert, otherOp.insert)) {\n            delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));\n          } else {\n            delta.push(otherOp)['delete'](opLength);\n          }\n\n          break;\n      }\n\n      length -= opLength;\n    }\n  });\n  return delta.chop();\n};\n\nDelta.prototype.eachLine = function (predicate, newline) {\n  newline = newline || '\\n';\n  var iter = op.iterator(this.ops);\n  var line = new Delta();\n  var i = 0;\n\n  while (iter.hasNext()) {\n    if (iter.peekType() !== 'insert') return;\n    var thisOp = iter.peek();\n    var start = op.length(thisOp) - iter.peekLength();\n    var index = typeof thisOp.insert === 'string' ? thisOp.insert.indexOf(newline, start) - start : -1;\n\n    if (index < 0) {\n      line.push(iter.next());\n    } else if (index > 0) {\n      line.push(iter.next(index));\n    } else {\n      if (predicate(line, iter.next(1).attributes || {}, i) === false) {\n        return;\n      }\n\n      i += 1;\n      line = new Delta();\n    }\n  }\n\n  if (line.length() > 0) {\n    predicate(line, {}, i);\n  }\n};\n\nDelta.prototype.transform = function (other, priority) {\n  priority = !!priority;\n\n  if (typeof other === 'number') {\n    return this.transformPosition(other, priority);\n  }\n\n  var thisIter = op.iterator(this.ops);\n  var otherIter = op.iterator(other.ops);\n  var delta = new Delta();\n\n  while (thisIter.hasNext() || otherIter.hasNext()) {\n    if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {\n      delta.retain(op.length(thisIter.next()));\n    } else if (otherIter.peekType() === 'insert') {\n      delta.push(otherIter.next());\n    } else {\n      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n      var thisOp = thisIter.next(length);\n      var otherOp = otherIter.next(length);\n\n      if (thisOp['delete']) {\n        // Our delete either makes their delete redundant or removes their retain\n        continue;\n      } else if (otherOp['delete']) {\n        delta.push(otherOp);\n      } else {\n        // We retain either their retain or insert\n        delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));\n      }\n    }\n  }\n\n  return delta.chop();\n};\n\nDelta.prototype.transformPosition = function (index, priority) {\n  priority = !!priority;\n  var thisIter = op.iterator(this.ops);\n  var offset = 0;\n\n  while (thisIter.hasNext() && offset <= index) {\n    var length = thisIter.peekLength();\n    var nextType = thisIter.peekType();\n    thisIter.next();\n\n    if (nextType === 'delete') {\n      index -= Math.min(length, index - offset);\n      continue;\n    } else if (nextType === 'insert' && (offset < index || !priority)) {\n      index += length;\n    }\n\n    offset += length;\n  }\n\n  return index;\n};\n\nmodule.exports = Delta;","map":{"version":3,"sources":["/home/thatguy/My-repos/Javascript/React/docs-clone/client/node_modules/quill-delta/lib/delta.js"],"names":["diff","require","equal","extend","op","NULL_CHARACTER","String","fromCharCode","Delta","ops","Array","isArray","prototype","insert","text","attributes","newOp","length","Object","keys","push","retain","index","lastOp","unshift","splice","chop","pop","filter","predicate","forEach","map","partition","passed","failed","target","reduce","initial","changeLength","elem","delete","slice","start","end","Infinity","iter","iterator","hasNext","nextOp","next","compose","other","thisIter","otherIter","firstOther","peek","firstLeft","peekType","peekLength","delta","Math","min","thisOp","otherOp","rest","concat","strings","prep","Error","join","diffResult","component","opLength","INSERT","DELETE","EQUAL","eachLine","newline","line","i","indexOf","transform","priority","transformPosition","offset","nextType","module","exports"],"mappings":"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","sourcesContent":["var diff = require('fast-diff');\nvar equal = require('deep-equal');\nvar extend = require('extend');\nvar op = require('./op');\n\n\nvar NULL_CHARACTER = String.fromCharCode(0);  // Placeholder char for embed in diff()\n\n\nvar Delta = function (ops) {\n  // Assume we are given a well formed ops\n  if (Array.isArray(ops)) {\n    this.ops = ops;\n  } else if (ops != null && Array.isArray(ops.ops)) {\n    this.ops = ops.ops;\n  } else {\n    this.ops = [];\n  }\n};\n\n\nDelta.prototype.insert = function (text, attributes) {\n  var newOp = {};\n  if (text.length === 0) return this;\n  newOp.insert = text;\n  if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {\n    newOp.attributes = attributes;\n  }\n  return this.push(newOp);\n};\n\nDelta.prototype['delete'] = function (length) {\n  if (length <= 0) return this;\n  return this.push({ 'delete': length });\n};\n\nDelta.prototype.retain = function (length, attributes) {\n  if (length <= 0) return this;\n  var newOp = { retain: length };\n  if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {\n    newOp.attributes = attributes;\n  }\n  return this.push(newOp);\n};\n\nDelta.prototype.push = function (newOp) {\n  var index = this.ops.length;\n  var lastOp = this.ops[index - 1];\n  newOp = extend(true, {}, newOp);\n  if (typeof lastOp === 'object') {\n    if (typeof newOp['delete'] === 'number' && typeof lastOp['delete'] === 'number') {\n      this.ops[index - 1] = { 'delete': lastOp['delete'] + newOp['delete'] };\n      return this;\n    }\n    // Since it does not matter if we insert before or after deleting at the same index,\n    // always prefer to insert first\n    if (typeof lastOp['delete'] === 'number' && newOp.insert != null) {\n      index -= 1;\n      lastOp = this.ops[index - 1];\n      if (typeof lastOp !== 'object') {\n        this.ops.unshift(newOp);\n        return this;\n      }\n    }\n    if (equal(newOp.attributes, lastOp.attributes)) {\n      if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {\n        this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };\n        if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes\n        return this;\n      } else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {\n        this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };\n        if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes\n        return this;\n      }\n    }\n  }\n  if (index === this.ops.length) {\n    this.ops.push(newOp);\n  } else {\n    this.ops.splice(index, 0, newOp);\n  }\n  return this;\n};\n\nDelta.prototype.chop = function () {\n  var lastOp = this.ops[this.ops.length - 1];\n  if (lastOp && lastOp.retain && !lastOp.attributes) {\n    this.ops.pop();\n  }\n  return this;\n};\n\nDelta.prototype.filter = function (predicate) {\n  return this.ops.filter(predicate);\n};\n\nDelta.prototype.forEach = function (predicate) {\n  this.ops.forEach(predicate);\n};\n\nDelta.prototype.map = function (predicate) {\n  return this.ops.map(predicate);\n};\n\nDelta.prototype.partition = function (predicate) {\n  var passed = [], failed = [];\n  this.forEach(function(op) {\n    var target = predicate(op) ? passed : failed;\n    target.push(op);\n  });\n  return [passed, failed];\n};\n\nDelta.prototype.reduce = function (predicate, initial) {\n  return this.ops.reduce(predicate, initial);\n};\n\nDelta.prototype.changeLength = function () {\n  return this.reduce(function (length, elem) {\n    if (elem.insert) {\n      return length + op.length(elem);\n    } else if (elem.delete) {\n      return length - elem.delete;\n    }\n    return length;\n  }, 0);\n};\n\nDelta.prototype.length = function () {\n  return this.reduce(function (length, elem) {\n    return length + op.length(elem);\n  }, 0);\n};\n\nDelta.prototype.slice = function (start, end) {\n  start = start || 0;\n  if (typeof end !== 'number') end = Infinity;\n  var ops = [];\n  var iter = op.iterator(this.ops);\n  var index = 0;\n  while (index < end && iter.hasNext()) {\n    var nextOp;\n    if (index < start) {\n      nextOp = iter.next(start - index);\n    } else {\n      nextOp = iter.next(end - index);\n      ops.push(nextOp);\n    }\n    index += op.length(nextOp);\n  }\n  return new Delta(ops);\n};\n\n\nDelta.prototype.compose = function (other) {\n  var thisIter = op.iterator(this.ops);\n  var otherIter = op.iterator(other.ops);\n  var ops = [];\n  var firstOther = otherIter.peek();\n  if (firstOther != null && typeof firstOther.retain === 'number' && firstOther.attributes == null) {\n    var firstLeft = firstOther.retain;\n    while (thisIter.peekType() === 'insert' && thisIter.peekLength() <= firstLeft) {\n      firstLeft -= thisIter.peekLength();\n      ops.push(thisIter.next());\n    }\n    if (firstOther.retain - firstLeft > 0) {\n      otherIter.next(firstOther.retain - firstLeft);\n    }\n  }\n  var delta = new Delta(ops);\n  while (thisIter.hasNext() || otherIter.hasNext()) {\n    if (otherIter.peekType() === 'insert') {\n      delta.push(otherIter.next());\n    } else if (thisIter.peekType() === 'delete') {\n      delta.push(thisIter.next());\n    } else {\n      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n      var thisOp = thisIter.next(length);\n      var otherOp = otherIter.next(length);\n      if (typeof otherOp.retain === 'number') {\n        var newOp = {};\n        if (typeof thisOp.retain === 'number') {\n          newOp.retain = length;\n        } else {\n          newOp.insert = thisOp.insert;\n        }\n        // Preserve null when composing with a retain, otherwise remove it for inserts\n        var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');\n        if (attributes) newOp.attributes = attributes;\n        delta.push(newOp);\n\n        // Optimization if rest of other is just retain\n        if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {\n          var rest = new Delta(thisIter.rest());\n          return delta.concat(rest).chop();\n        }\n\n      // Other op should be delete, we could be an insert or retain\n      // Insert + delete cancels out\n      } else if (typeof otherOp['delete'] === 'number' && typeof thisOp.retain === 'number') {\n        delta.push(otherOp);\n      }\n    }\n  }\n  return delta.chop();\n};\n\nDelta.prototype.concat = function (other) {\n  var delta = new Delta(this.ops.slice());\n  if (other.ops.length > 0) {\n    delta.push(other.ops[0]);\n    delta.ops = delta.ops.concat(other.ops.slice(1));\n  }\n  return delta;\n};\n\nDelta.prototype.diff = function (other, index) {\n  if (this.ops === other.ops) {\n    return new Delta();\n  }\n  var strings = [this, other].map(function (delta) {\n    return delta.map(function (op) {\n      if (op.insert != null) {\n        return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;\n      }\n      var prep = (delta === other) ? 'on' : 'with';\n      throw new Error('diff() called ' + prep + ' non-document');\n    }).join('');\n  });\n  var delta = new Delta();\n  var diffResult = diff(strings[0], strings[1], index);\n  var thisIter = op.iterator(this.ops);\n  var otherIter = op.iterator(other.ops);\n  diffResult.forEach(function (component) {\n    var length = component[1].length;\n    while (length > 0) {\n      var opLength = 0;\n      switch (component[0]) {\n        case diff.INSERT:\n          opLength = Math.min(otherIter.peekLength(), length);\n          delta.push(otherIter.next(opLength));\n          break;\n        case diff.DELETE:\n          opLength = Math.min(length, thisIter.peekLength());\n          thisIter.next(opLength);\n          delta['delete'](opLength);\n          break;\n        case diff.EQUAL:\n          opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);\n          var thisOp = thisIter.next(opLength);\n          var otherOp = otherIter.next(opLength);\n          if (equal(thisOp.insert, otherOp.insert)) {\n            delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));\n          } else {\n            delta.push(otherOp)['delete'](opLength);\n          }\n          break;\n      }\n      length -= opLength;\n    }\n  });\n  return delta.chop();\n};\n\nDelta.prototype.eachLine = function (predicate, newline) {\n  newline = newline || '\\n';\n  var iter = op.iterator(this.ops);\n  var line = new Delta();\n  var i = 0;\n  while (iter.hasNext()) {\n    if (iter.peekType() !== 'insert') return;\n    var thisOp = iter.peek();\n    var start = op.length(thisOp) - iter.peekLength();\n    var index = typeof thisOp.insert === 'string' ?\n      thisOp.insert.indexOf(newline, start) - start : -1;\n    if (index < 0) {\n      line.push(iter.next());\n    } else if (index > 0) {\n      line.push(iter.next(index));\n    } else {\n      if (predicate(line, iter.next(1).attributes || {}, i) === false) {\n        return;\n      }\n      i += 1;\n      line = new Delta();\n    }\n  }\n  if (line.length() > 0) {\n    predicate(line, {}, i);\n  }\n};\n\nDelta.prototype.transform = function (other, priority) {\n  priority = !!priority;\n  if (typeof other === 'number') {\n    return this.transformPosition(other, priority);\n  }\n  var thisIter = op.iterator(this.ops);\n  var otherIter = op.iterator(other.ops);\n  var delta = new Delta();\n  while (thisIter.hasNext() || otherIter.hasNext()) {\n    if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {\n      delta.retain(op.length(thisIter.next()));\n    } else if (otherIter.peekType() === 'insert') {\n      delta.push(otherIter.next());\n    } else {\n      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n      var thisOp = thisIter.next(length);\n      var otherOp = otherIter.next(length);\n      if (thisOp['delete']) {\n        // Our delete either makes their delete redundant or removes their retain\n        continue;\n      } else if (otherOp['delete']) {\n        delta.push(otherOp);\n      } else {\n        // We retain either their retain or insert\n        delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));\n      }\n    }\n  }\n  return delta.chop();\n};\n\nDelta.prototype.transformPosition = function (index, priority) {\n  priority = !!priority;\n  var thisIter = op.iterator(this.ops);\n  var offset = 0;\n  while (thisIter.hasNext() && offset <= index) {\n    var length = thisIter.peekLength();\n    var nextType = thisIter.peekType();\n    thisIter.next();\n    if (nextType === 'delete') {\n      index -= Math.min(length, index - offset);\n      continue;\n    } else if (nextType === 'insert' && (offset < index || !priority)) {\n      index += length;\n    }\n    offset += length;\n  }\n  return index;\n};\n\n\nmodule.exports = Delta;\n"]},"metadata":{},"sourceType":"script"}